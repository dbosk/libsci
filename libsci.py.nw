\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[british]{babel}
\usepackage{authblk}
\usepackage[binary,amssymb]{SIunits}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{commath}
\usepackage[defblank]{paralist}

\usepackage{listings}
\lstset{%
  language=Python,
  numbers=left,
  tabsize=2,
  basicstyle=\small,
  frame=topbottom
}

\usepackage[natbib,style=alphabetic]{biblatex}
\addbibresource{libsci.bib}

\usepackage{noweb}
% Needed to relax penalty for breaking code chunks across pages, otherwise 
% there might be a lot of space following a code chunk.
\def\nwendcode{\endtrivlist \endgroup}
\let\nwdocspar=\smallbreak

\usepackage{csquotes}
\MakeBlockQuote{<}{ยง}{>}
\EnableQuotes

%\usepackage[natbib,style=alphabetic,backend=bibtexu]{biblatex}
%\addbibresource{libsci.bib}

\title{%
  libsci: Python for Scientific Precision in Writing
}
\author[1]{Daniel Bosk}
\affil[1]{%
  School of Computer Science and Communication,
  KTH Royal Institute of Technology, SE-100\,44 Stockholm.
  Email: \texttt{dbosk@kth.se}
}
\author[2]{Mitra Damghaninan}
\affil[2]{%
  Email: \texttt{mitra@damghanian.se}
}
\date{Version 1.0 (draft)}

\begin{document}
\maketitle

%\begin{abstract}
%\dots
%\end{abstract}

\tableofcontents

@
\section{Introduction}

This library is intended as an interface between a LaTeX paper and the tools 
used for running the experiments.
It is intended to be used with e.g.~PythonTeX, so the output is optimized to be 
typeset in LaTeX rather than being output in the terminal.

\subsection{Outline}
\label{sec:Outline}

The program is a Python 3 module, [[<<libsci.py>>]].
The module has the following structure:
<<libsci.py>>=
<<imports>>
<<functions>>
<<classes>>
@ The code chunk [[<<imports>>]] will contain our imported modules.
The code chunks [[<<classes>>]] and [[<<functions>>]] will contain our classes 
and functions, respectively.
Throughout this paper we will add code to these chunks.
Each section is independent and focuses on one functionality provided by the 
library.


\section{The SciDecimal Class}

The [[SciDecimal]] class extends the class [[Decimal]] from Python's 
[[decimal]] module.
The extended functionality is keeping track of the significant digits, so that 
the correct number of digits is used when printed.
To be able to do this we need to overload certain operators in the parent 
([[super]]) class.
We start with the following overview structure of the class:
<<classes>>=
class SciDecimal (decimal.Decimal):
  <<SciDecimal constructors>>
  <<SciDecimal methods>>
  <<SciDecimal overloaded operators>>
@ And we need to import the [[decimal]] module:
<<imports>>=
import decimal
@

\subsection{Computing the Mean}

Since we base our class on the [[Decimal]] class, we can also rely on Python's 
[[statistics]] module to compute mean, variance and standard deviation.
We illustrate this use with the small example in List.~\ref{fig:pystatistics}.
\begin{lstlisting}[float,caption={An example program using SciDecimal and 
Python's statistics.},label={fig:pystatistics}]
import libsci
import statistics

values = list( map( \
  lambda x: libsci.SciDecimal( x ), \
  [ 1, 2, 3, 4, 5 ] ) )

print( "mean: %s" % ( statistics.mean( values ) ) )
print( "stddev: %s" % ( statistics.stdev( values ) ) )
\end{lstlisting}


\section{The TeXDecimal Class}

<<classes>>=
class TeXDecimal (SciDecimal):
  <<TeXDecimal constructors>>
  <<TeXDecimal methods>>
  <<TeXDecimal overloaded operators>>
@

<<TeXDecimal methods>>=
def __str__( self ):
  exponent = math.floor( math.log10( x ) )
  ret = ( "{:." + str(n-1) + "f}" ).format( \
    round( x / math.pow( 10, exponent ), n-1 ) )
  ret += r"\times 10^{" + str( int( exponent ) )
  ret += r"}"
  return ret
@


\section{The StatDecimal Class}
\label{sec:StatDecimal}

A stochastic parameter has some sort of randomness (non-deterministic nature) and is associated with a probability distribution. To do statistical analysis we need statistical modelling and for that we need to know what is the probability distribution of the stochastic parameter. One way to find out what probability distribution the stochastic parameter has is to have a large number of observations and then look into the histogram of those observations. The next step is a model selection, which is the task of selecting a statistical model from a set of candidate models. After model selection, we can extract the model parameters with e.g. curve fitting method. 

To be able to add and multiply stochastic parameters, we need the knowledge of the algebra for stochastic parameters. Since we encounter many stochastic parameters which have normal probability distribution, it is worthy to look into the algebra of normal distributions:

\begin{itemize}

\item What is the sum of two independent stochastic parameters each having a normal distribution? 
The sum is another stochastic parameter with the mean equal to the sum of the 
means and variance equal to the sum of the variances,
\begin{align}
\mu_{X+Y} &= \mu_{X} + \mu_{Y} \\
\sigma^{2}_{X+Y} &= \sigma^{2}_{X} + \sigma^{2}_{Y}.
\end{align}

\item What is the difference of two independent stochastic parameters each having a normal distribution? 
The difference is another stochastic parameter with the mean equal to the 
difference of the means and variance equal to the sum of the variances,
\begin{align}
\mu_{X-Y} &= \mu_{X} - \mu_{Y} \\
\sigma^{2}_{X-Y} &= \sigma^{2}_{X} + \sigma^{2}_{Y}.
\end{align}

\item What is the ratio of two independent stochastic parameters each having a normal distribution?
Assuming both distributions have a mean equal to zero, the ratio will be another stochastic parameter with a new type of probability distribution called Cauchy distribution,
\begin{align}
U &= \frac{X}{Y} \\
P(U) &=  \frac{\frac{\sigma_{X}}{\sigma_{Y}}}{\pi\times \left(u^{2} 
+ \frac{\sigma_{X}}{\sigma_{Y}}^2\right)}.
\end{align}

\item What is the multiplication of two independent stochastic parameters each having a normal distribution? 
Assuming both distributions have a mean equal to zero, the multiplication will be another stochastic parameter with a new type of probability distribution as:
\begin{align}
U &= X\times Y \\
P(U) &= \frac{K_{0} \frac{|u|}{\sigma_{X} \sigma_{Y}}}{\pi \sigma_{X} 
\sigma_{Y}}.
\end{align}
where \(K_{n}(z)\) is the modified Bessel function of the second kind and
\begin{equation}
K_{0}(z) = \int_{0}^{\infty}\frac{\cos(zt)}{\sqrt{t^2+1}} \dif t.
\end{equation}

\end{itemize}

\subsection{Implementation}

The [[StatDecimal]] class further extends the [[SciDecimal]] class in that it 
correctly keeps track of the statistical parameters throughout chains of 
arithmetic operations.
This means that we want to do arithmetic with stochastic parameters.
We start with the following overview of the class:
<<classes>>=
class StatDecimal (SciDecimal):
  <<StatDecimal constructors>>
  <<StatDecimal methods>>
  <<StatDecimal overloaded operators>>
@

To construct a [[StatDecimal]] <number>, i.e.~a stochastic parameter, we need 
a value, its variance and its statistical distribution.
Thus we define the default constructor as
<<StatDecimal constructors>>=
def __init__( self, value, variance=0 ):
  super( value )
  self.__variance = SciDecimal( variance )
@ We let the standard deviation ([[variance]] attribute) default to zero, as 
that is the expected behaviour for non-statistical values.
We do not store a separate value, we rely on the parent class ([[super]]) for 
that.

We also want to have a way of reading the stochastic parameters from an object.
To achieve this we add a methods for each parameter, e.g.~variance or standard 
deviation.
We already know the variance, so it is easy to just have a method to return it:
<<StatDecimal methods>>=
def variance( self ):
  return self.__variance
@ Similarly, it is easy to compute the standard deviation from the variance, so 
we can also add this method:
<<StatDecimal methods>>=
def stddev( self ):
  return self.__variance.sqrt()
@

\subsection{Overloaded Addition and Multiplication}

The operators we need to overload are
\begin{inparablank}
\item addition (and subtraction) and
\item multiplication (and division).
\end{inparablank}
For addition, we let
<<StatDecimal overloaded operators>>=
def __add__( self, other ):
  super.__add__( other )
  <<handle variance for addition>>
@ We let the super class handle the actual addition, we only need to handle the 
standard deviation properly.
For addition, the resultant standard deviation should be the larger of the two, 
hence we let
<<handle variance for addition>>=
self.__variance = self.__variance + other.__variance
@ Subtraction is different from addition.
We need to handle the variance differently, but we can define subtraction 
similarly as addition:
<<StatDecimal overloaded operators>>=
def __sub__( self, other ):
  super.__sub__( other )
  <<handle variance for subtraction>>
@ The variance in a subtraction operation must be handled as
<<handle variance for subtraction>>=
pass
@

Multiplication and division are much different as multiplication of two 
variables changes the statistical distribution.
For now, we let
<<StatDecimal overloaded operators>>=
def __mul__( self, other ):
  super.__mul__( other )
  <<handle variance for multiplication>>
def __div__( self, other ):
  super.__div__( other )
  <<handle variance for division>>
@

\subsection{Overloaded String Conversion}

\dots


\section{Future Work}
\label{sec:FutureWork}

There are things that would be worth extending in this solution.
We give a list below, somewhat in order of priority.
(Or order of complexity, so easiest first.)

\dots


\section*{Acknowledgements}

This program was developed as part of my research.
Hence this program's development was funded by
the Swedish Foundation for Strategic Research grant SSF FFL09-0086
and the Swedish Research Council grant VR 2009-3793.

This code is available under the following MIT license:
\begin{quote}
  \input{LICENSE}
\end{quote}


\printbibliography


\section*{An Index of the Code Blocks}

\nowebchunks
\end{document}
